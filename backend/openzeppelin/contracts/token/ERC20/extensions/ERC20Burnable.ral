// Ralph Translation of ERC20Burnable
// ====================================
// @@@ In Ralph, native burnToken!() permanently removes tokens from circulation. To match ERC20 semantics where burned tokens can be re-minted, the contract simply accepts the deposit and recudes totalSupply.
Abstract Contract FungibleTokenBurnable(mut tokenMetadata: FungibleTokenMetadata) {

    // =========================================================================
    // burn(uint256 value)
    // =========================================================================
    // Burns tokens from the caller's account by depositing them to the contract.
    // The caller must approve the tokens in the transaction using preapprovedAssets.
    //
    // Usage:
    //   token.burn{caller -> tokenId: amount}(amount)
    // @@@ Burn in ERC20 sense - tokens are not removed permanently
    @using(preapprovedAssets = true, checkExternalCaller = false, updateFields = true, payToContractOnly = true)
    pub fn burn(amount: U256) -> () {
        transferTokenToSelf!(callerAddress!(), selfTokenId!(), amount)
        tokenMetadata.totalSupply = tokenMetadata.totalSupply - amount
    }

    // =========================================================================
    // burnFrom(address account, uint256 value)
    // =========================================================================
    // Usage:
    //   token.burnFrom{owner -> tokenId: amount}(owner, amount)
    //
    // @@@ `from` address MUST be part of the transaction (signing or approving assets), whereas in ERC20 the owner can pre-approve and the spender can burn later without owner involvement.
    @using(preapprovedAssets = true, checkExternalCaller = false, updateFields = true, payToContractOnly = true)
    pub fn burnFrom(from: Address, amount: U256) -> () {
        transferTokenToSelf!(from, selfTokenId!(), amount)
        tokenMetadata.totalSupply = tokenMetadata.totalSupply - amount
    }
}
