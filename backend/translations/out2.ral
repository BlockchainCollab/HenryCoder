Interface IStack {
  event Popped(value: U256)
  event Pushed(value: U256)

  @using(updateFields = true)
  pub fn push(value: U256) -> ()
  pub fn pop() -> ()
}

// @@@ Ralph uses explicit mappings for dynamic arrays; Solidity has native dynamic array type with length property and push/pop methods
Contract Array(
  mut arrLength: U256,
  mut arr2Length: U256,
  // @@@ Ralph requires fixed-size arrays as contract fields; Solidity allows both storage and memory arrays with dynamic sizing
  mut myFixedSizeArr: [U256; 10]
) implements IStack {

  mapping[U256, U256] arr
  // @@@ Ralph doesn't support default mapping values; Solidity mappings return zero for uninitialized keys
  mapping[U256, U256] arr2

  // @@@ Ralph initializes state in contract parameters; Solidity uses constructor functions for initialization logic
  @using(updateFields = true, checkExternalCaller = false)
  pub fn setFixed(index: U256, value: U256) -> () {
    // @@@ Ralph panics on array out-of-bounds access; Solidity reverts with error message
    myFixedSizeArr[index] = value
  }

  // @@@ Ralph requires explicit contains! check for safe map access; Solidity returns zero for missing keys automatically
  pub fn get(i: U256) -> U256 {
    // Only show below code if mimic solidity defaults is set to true:
    // >>>>>
    if (!arr.contains!(i)) {
      return 0
    }
    // <<<<<
    return arr[i]
  }

  // @@@ Ralph cannot return entire mappings or iterate over keys; Solidity allows returning storage arrays
  // pub fn getArr() -> () {
  //     Not possible in Ralph
  // }

  // @@@ Ralph uses insert! method for adding map entries; Solidity uses direct assignment for array push
  @using(updateFields = true, checkExternalCaller = false)
  pub fn push(i: U256) -> () {
    arr.insert!(arrLength, i)
    arrLength = arrLength + 1
  }

  @using(updateFields = true, checkExternalCaller = false)
  pub fn push2(i: U256) -> () {
    emit Pushed(i)
    arr2.insert!(arr2Length, i)
    arr2Length = arr2Length + 1
  }

  // @@@ Ralph requires manual length tracking and remove! call; Solidity's pop() automatically handles both length and storage cleanup
  @using(updateFields = true, checkExternalCaller = false)
  pub fn pop() -> () {
    arrLength = arrLength - 1
    arr.remove!(arrLength)
  }

  pub fn getLength() -> U256 {
    return arrLength
  }

  // @@@ Ralph uses explicit panic! for errors; Solidity uses revert/require with error messages
  @using(updateFields = true, checkExternalCaller = false)
  pub fn remove(index: U256) -> () {
    if (index >= arrLength) {
      panic!()
    }
    arr.remove!(index)
  }

  // @@@ Ralph only supports fixed-size local arrays; Solidity supports both memory and storage dynamic arrays
  pub fn examples() -> U256 {
    let a = [0; 5]

    // @@@ Ralph supports nested fixed-size arrays; Solidity allows dynamic nested arrays in memory
    let b = [[1, 2, 3], [4, 5, 6]]

    return a[0] + b[0][0]
  }
}