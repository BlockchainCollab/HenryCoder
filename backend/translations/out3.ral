// @@@ Ralph requires struct definitions outside contracts; Solidity allows nested struct declarations within contracts
struct Game {
  mut playerOne: Address,
  mut playerTwo: Address,
  mut stake: U256,
  mut playerOneChoice: U256,
  mut playerTwoChoice: U256,
  mut playerOneHash: ByteVec,
  mut playerTwoHash: ByteVec,
  mut status: U256,
  mut outcome: U256
}

// @@@ Ralph has built-in reentrancy protection at protocol level; Solidity requires explicit ReentrancyGuard inheritance
Contract RPSv2() {
  mapping[Address, Game] games
  mapping[Address, U256] playerBalances

  event GetGameOutcome(outcome: U256)

  enum GameStatus {
    NonExistent = 0
    Started = 1
    Participated = 2
  }

  enum GameOutcome {
    Draw = 0
    PlayerOne = 1
    PlayerTwo = 2
  }

  enum ErrorCodes {
    GameHashNotProvided = 1001
    ProblemWithOtherPlayer = 1002
    OldGameOrNoGame = 1003
    PlayersFundsInsufficient = 1004
    YouAreNotPlayer2 = 1005
    GameNotStarted = 1006
    PlayerFundsInsufficient = 1007
    GameNotReady = 1008
    InvalidSalt = 1009
    InvalidPlayer = 1010
    ChoicesNotRevealed = 1011
    InvalidOutcome = 1012
    NoBalance = 1013
  }

  // @@@ Ralph uses @using(preapprovedAssets=true) for token transfers; Solidity uses msg.value for ETH transfers
  @using(updateFields = true, preapprovedAssets = true, checkExternalCaller = false)
  pub fn startGame(gameHash: ByteVec, opponent: Address, gameStake: U256) -> () {
    let caller = callerAddress!()
    
    // @@@ Ralph uses # for empty ByteVec; Solidity uses bytes32(0) or empty bytes
    assert!(gameHash != #, ErrorCodes.GameHashNotProvided)
    assert!(opponent != nullContractAddress!() && opponent != caller, ErrorCodes.ProblemWithOtherPlayer)
    // @@@ Ralph requires explicit mapping access check; Solidity mappings auto-initialize with default values
    assert!(games[caller].status == GameStatus.NonExistent, ErrorCodes.OldGameOrNoGame)
    assert!(gameStake <= playerBalances[caller], ErrorCodes.PlayersFundsInsufficient)

    playerBalances[caller] = playerBalances[caller] - gameStake
    
    // @@@ Ralph requires all struct fields to be mutable for reassignment; Solidity allows selective field mutability
    let newGame = Game {
      playerOne: caller,
      playerTwo: opponent,
      stake: gameStake,
      playerOneChoice: 0,
      playerTwoChoice: 0,
      playerOneHash: gameHash,
      playerTwoHash: #,
      status: GameStatus.Started,
      outcome: GameOutcome.Draw
    }
    games[caller] = newGame
  }

  @using(updateFields = true, preapprovedAssets = true, checkExternalCaller = false)
  pub fn participateGame(gameHash: ByteVec, opponent: Address) -> () {
    let caller = callerAddress!()
    
    assert!(gameHash != #, ErrorCodes.GameHashNotProvided)
    assert!(opponent != nullContractAddress!(), ErrorCodes.ProblemWithOtherPlayer)
    assert!(games[opponent].playerTwo == caller, ErrorCodes.YouAreNotPlayer2)
    assert!(games[opponent].status == GameStatus.Started, ErrorCodes.GameNotStarted)

    let gameStake = games[opponent].stake
    assert!(gameStake <= playerBalances[caller], ErrorCodes.PlayerFundsInsufficient)

    playerBalances[caller] = playerBalances[caller] - gameStake

    // @@@ Ralph requires explicit mut keyword for mutable local variables; Solidity infers mutability from usage
    let mut game = games[opponent]
    game.playerTwoHash = gameHash
    game.status = GameStatus.Participated
    games[opponent] = game
  }

  @using(updateFields = true, checkExternalCaller = false)
  pub fn revealChoice(choice: U256, salt: ByteVec, playerOne: Address) -> () {
    let caller = callerAddress!()
    let mut game = games[playerOne]
    
    assert!(game.status == GameStatus.Participated, ErrorCodes.GameNotReady)
    
    if caller == game.playerOne {
      assert!(game.playerOneHash == getSaltedHash(choice, salt), ErrorCodes.InvalidSalt)
      game.playerOneChoice = choice
    } else if caller == game.playerTwo {
      assert!(game.playerTwoHash == getSaltedHash(choice, salt), ErrorCodes.InvalidSalt)
      game.playerTwoChoice = choice
    } else {
      // @@@ Ralph uses panic! for unrecoverable errors; Solidity uses revert() or require() for all reverts
      panic!(ErrorCodes.InvalidPlayer)
    }
    
    games[playerOne] = game
  }

  @using(updateFields = true, checkExternalCaller = false)
  pub fn endGame(playerOne: Address) -> U256 {
    let game = games[playerOne]
    
    assert!(
      game.playerOneChoice > 0 && game.playerTwoChoice > 0,
      ErrorCodes.ChoicesNotRevealed
    )
    
    let playerTwo = game.playerTwo
    let stake = game.stake
    let playerOneChoice = game.playerOneChoice
    let playerTwoChoice = game.playerTwoChoice
    
    // @@@ Ralph enums are U256 values without implicit casting; Solidity enums support implicit type conversion
    let gameResult = (3 + playerOneChoice - playerTwoChoice) % 3
    
    if gameResult == GameOutcome.Draw {
      playerBalances[playerOne] = playerBalances[playerOne] + stake
      playerBalances[playerTwo] = playerBalances[playerTwo] + stake
    } else if gameResult == GameOutcome.PlayerOne {
      playerBalances[playerOne] = playerBalances[playerOne] + stake * 2
    } else if gameResult == GameOutcome.PlayerTwo {
      playerBalances[playerTwo] = playerBalances[playerTwo] + stake * 2
    } else {
      panic!(ErrorCodes.InvalidOutcome)
    }
    
    games[playerOne] = Game{
      playerOne: nullContractAddress!(),
      playerTwo: nullContractAddress!(),
      stake: 0,
      playerOneChoice: 0,
      playerTwoChoice: 0,
      playerOneHash: #,
      playerTwoHash: #,
      status: GameStatus.NonExistent,
      outcome: GameOutcome.Draw
    }
    
    emit GetGameOutcome(gameResult)
    return gameResult
  }

  // @@@ Ralph uses keccak256! macro for hashing; Solidity uses keccak256() function
  fn getSaltedHash(answer: U256, salt: ByteVec) -> ByteVec {
    // @@@ Ralph uses encodeToByteVec! for encoding; Solidity uses abi.encodePacked()
    return keccak256!(encodeToByteVec!(answer, salt))
  }

  // @@@ Ralph uses tokenRemaining! to check approved token amounts; Solidity directly accesses msg.value for ETH
  @using(preapprovedAssets = true, updateFields = true, checkExternalCaller = false)
  pub fn deposit() -> () {
    let caller = callerAddress!()
    // @@@ Ralph requires explicit token approval before contract call; Solidity receives ETH directly with payable
    let amount = tokenRemaining!(caller, ALPH)
    playerBalances[caller] = playerBalances[caller] + amount
  }

  // @@@ Ralph uses transferTokenFromSelf! for contract-to-user transfers; Solidity uses address.transfer() or call{value:}
  @using(assetsInContract = true, updateFields = true, checkExternalCaller = false)
  pub fn withdraw() -> () {
    let caller = callerAddress!()
    let playerBalance = playerBalances[caller]
    
    assert!(playerBalance > 0, ErrorCodes.NoBalance)
    // @@@ Ralph requires zeroing balance before transfer to prevent reentrancy; Solidity relies on ReentrancyGuard or checks-effects-interactions pattern
    playerBalances[caller] = 0
    
    transferTokenFromSelf!(caller, ALPH, playerBalance)
  }

  @using(assetsInContract = true, checkExternalCaller = false)
  pub fn getContractBalance() -> U256 {
    // @@@ Ralph uses selfAddress! to reference contract; Solidity uses address(this)
    return tokenRemaining!(selfAddress!(), ALPH)
  }

  pub fn getPlayerBalance(playerAddress: Address) -> U256 {
    return playerBalances[playerAddress]
  }

  // @@@ Ralph uses externalCallerAddress! to get original caller; Solidity uses msg.sender which can be contract in delegatecall
  pub fn getMsgSender() -> Address {
    return externalCallerAddress!()
  }
}